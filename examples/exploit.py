#!/usr/bin/python3

import os
import sys
import pickle
import string
import random
import requests


# Disables pretty terminal settings and animations so the script can be executed outside a terminal.
os.environ['PWNLIB_NOTERM'] = '1'


def get_persistent_data(pickle_path):
    """Unserialize and return the provided pickle file."""

    try:
        with open(pickle_path, 'rb') as f:
            data = pickle.load(f)
    except:
        data = dict()

    return data 


def save_persistent_data(pickle_path, data):
    """Save data as a pickle file, can be used to serialize python objects."""

    with open(pickle_path, 'wb') as f:
        try:
            pickle.dump(data, f, protocol=pickle.HIGHEST_PROTOCOL)
        except:
            pass


def gen_random_str(n, charset):
    """Get a random string of length n from the provided charset.

    Example:

    >>> gen_random_str(15, string.ascii_uppercase + string.digits)
    '9T9UINWLBTDNUS2'
    """

    return ''.join(random.choice(charset) for _ in range(n))

def get_random_ua():
    """Get a random User-Agent."""

    ua_list = [
        'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/107.0.0.0 Safari/537.36',
        'Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:106.0) Gecko/20100101 Firefox/106.0',
        'python-requests/2.28.1',
        'python-requests/2.28.0',
        'python-requests/2.27.1',
        'python-requests/2.27.0',
        'python-requests/2.26.0',
        'python-requests/2.25.1',
        'python-requests/2.25.0',
        'python-requests/2.24.0',
        'python-requests/2.23.0',
        'python-requests/2.22.0',
        'python-requests/2.21.0',
        'python-requests/2.20.1',
        'python-requests/2.20.0'
    ]

    return random.choice(ua_list)


def exploit(ip):
    """Attack a single team and print flags. No need to print only flags here, output can be messy."""

    url = 'http://{}:1234/'.format(ip)

    # use sessions if you need to maintain a session across several requests
    s = requests.Session()
    r = s.post(url + 'login.php', data={'username': 'foo', 'password': 'bar'}) # log-in
    r = s.get(url + 'index.php') # logged in!

    # HTTP methods
    r = requests.get(url, headers={'User-Agent': randua()})
    r = requests.post(url)
    r = requests.put(url)
    r = requests.delete(url)
    r = requests.head(url)
    r = requests.options(url)
    r = requests.request('MYGET', url) # custom HTTP method

    # requests parameters
    r = requests.get(url,
        # query string parameters
        params={'key1': 'value', 'key2': ['multiple', 'values']},
        # request body data
        data={'form': 'mode'}, # or data='raw data here',
        # set custom headers
        headers={'user-agent': 'not a bot'},
        # send files content
        files={'filename': open('report.xls', 'rb'), 'file2': 'content as string'},
        # cookies as usual
        cookies={'name': 'value'},
        # skip SSL certificate verification
        verify=False,
        # disable redirect following
        allow_redirects=False,
        timeout=3, # in seconds
        auth=('user', 'pass') # BasicAuth
    )

    # for more options of request object
    # http://docs.python-requests.org/en/master/user/advanced/#prepared-requests

    # raw content of the response (as byte string): use this whenever possible since it's WAY faster than r.text!
    r.content
    # response content decoded with guessed encoding
    r.text

    # status code of the response, like 200, 404, 500...
    r.status_code
    # raise HTTPError in case of bad status code
    r.raise_for_status()

    # fetch headers or cookies
    r.headers['Header-Name']
    r.cookies['cookie_name']

    # list of previous response objects (in case of redirection)
    r.history

    # EXCEPTIONS in requests.exceptions
    # ConnectionError - network problem (e.g. DNS failure, refused connection, etc)
    # HTTPError - if the HTTP request returned an unsuccessful status code
    # Timeout - if a request times out
    # TooManyRedirects - if a request exceeds the configured number of maximum redirections


def die(message):
    sys.stderr.write('[!] {}\n'.format(message))
    sys.exit(1)


def main():
    # get exploit parameters    
    try:
        ip, team_id = sys.argv[1:3]
    except ValueError:
        die('Usage: {} <team_ip> <team_id> [flag_id ...]'.format(sys.argv[0]))

    if len(sys.argv) > 3:
        flag_ids = sys.argv[3:]

    print(ip, team_id, flag_ids)

    exploit(ip)
    sys.exit(0)
    

if __name__ == '__main__':
    main()